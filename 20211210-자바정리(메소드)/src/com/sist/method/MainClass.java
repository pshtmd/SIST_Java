package com.sist.method;
/*
 * 메소드 굉장히 중요오오오오오오
 * 사이트를 보자마자 어떤 변수가 필요한지
 * 어떤 걸 요청해야 하는지 
 * 
 * 
 * 
 * 
 * 
 * 	 자바구조
 * 	package => 1번만 사용 가능
 * 	import => 라이브러리 읽기 (여러개 사용 가능)
 * 	public class ClassName
 * 	{
 * 		=====================
 * 		멤버변수 => 클래스에서 사용되는 변수 (9:1)
 * 			-인스턴스 변수 (개별변수) => new 를 사용할 때마다 따로 저장
 * 			-정적 변수(static) => 범위 (공유변수..하나가 바뀌면 전체가 바뀌는)
 * 
 * 			ex) 사람이름 => 인스턴스 변수로 저장 .. 따로 저장
 * 				학교명 => static 변수
 * 
 * 			=> 생성시기
 * 				인스턴스 ==> new , delete (자바 => 가비지컬렉션:자동 회수)
 * 							==> 바로 메모리에서 해제( System.gc() )
 * 								 멀티미디어 (동영상)
 * 				static ==> 클래스가 JVM에서 로딩 ( 읽어 온 경우에 )
 * 				
 * ***			접근범위
 * 			-----------------------------------------------------------------
 * 			 	자신 클래스  |  같은 패키지에 |  상속이 있는 경우  | 모든 클래스에 접근 가능
 * 						  |	 있는 클래스    다른 패키지에 있는 
 * 											클래스
 * 			----------------------------------------------------------------
 * 	private	    O
 * 			-----------------------------------------------------------------
 * 	default		O				O
 * 			-----------------------------------------------------------------
 * 	protected	O				O				O
 * 			-----------------------------------------------------------------
 * 	public 		O				O				O				O
 * 			-----------------------------------------------------------------
 * 
 * 			private : 은닉화 (다른 클래스에서 접근 금지) ==> 캡슐화
 * 					=> 변수' 잡을 경우 많이 사용됨
 * 			public : 공개 (모든 곳에서 사용 가능)  
 * 					=> 메소드 , 클래스, 생성자 
 * 
 * 			소스코딩 => 캡슐화 (메소드를 통해 접근하는 방식 ).. getter / setter
 * 					 변수 => 기능 (  읽기   /  쓰기  )
 * 								 getter  setter
 * 		===============================================================활용
 * 		 검색 , 저장 , 수정 , 삭제 => 기능을 만드는 것을 '메소드' 라고 함 ㅎㅎ=> 필요 시에 재사용 가능
 * 		=> 기능을 새롭게 추가 : 오버로딩(메소드 추가)...(새로운걸 만드는 거니까 'new'를 꼭 해야함)
 * 		=> 기존의 기능 변경 : 오버라이딩(메소드 재정의)
 * 
 * 
 * 		메소드 제작 (변수 / 연산자 / 제어문) 
 * 		1. 구성요소
 * 			메소드 : 선언부 / 구현부
 * 				  ======
 * 				   리턴형 => 사용자 요청시에 요청 처리에 대한 결과값
 * 						=> 단점: 한 개만 리턴 가능 ㅠ( 일반 데이터형으로 리턴 ) 
 * 								..여러개인 경우 묶어서 전송 ( 배열 / 클래스로 리턴)
 * 				   매개변수 => 요청가 (요청한 값)
 * 					웹=> 사용작 입력 => 메소드의 매개변수로 들어옴
 * 
 * 					
 * 		2. 메소드 형식 
 * 			접근지정어 (public) 리턴형(결과값)  메소드명(매개변수..)      *선언부
 * 							=> 결과값이 없는 경우 (void) 
 * 							.. 처리가 메소드 안'에서 이루어짐 
 * 			{
 * 				*구현부
 * 			}
 * 			메소드는 {} 구현 ==> 메모리 저장
 * 			메소드가 선언만 되어 있으면 => 메모리에 저장 불가능 
 * 								  ' 미완성된 클래스 '
 * 								 (추상클래스 , 인터페이스 )
 * 		=====================================
 * 			  	리턴형 		매개변수
 * 		=====================================
 * 				O			O
 * 		=====================================
 * 				O			X
 * 				SELECT
 * 		=====================================
 * 				X(void)   	O
 * 				==> INSERT / UPDATE / DELETE
 * 		=====================================
 * 				X(void)     X  ==> 극히 드물다
 * 
 * 		....모아놨다가 필요할때 다시 재사용하는 것을 객체지향이라 함
 * 		... 추가가 가능하고 수정이 가능하게 만들어놔야 객체지향 프로그램을 제대로 했다고 할 수 있음
 * 		===============================================================
 * 		네트워크 (게임, 실시간 채팅) => 쓰레드
 * 
 * ***	데이터베이스(웹) => 메소드** 이용
 * 		===============================================================
 * 
 * 		1. 멤버변수 => 초기값
 * 			= 명시적 초기화
 * 			  String id="admin" => 클래스에서는 선언만 가능!!
 * 			= 외부에서 데이터 읽기 (파일 , 오라클(DB) ) => 클래스 영역에서는 사용 불가  ( 구현=> {} )
 * 			  생성자=> 멤버변수의 초기화 
 * 				  => 클래스 동일
 * 				  => 리턴형이 없다 
 * 				  => 오버로딩을 지워
 * 				  => 서버연결 / 오라클 드라이버 설정 
 * 			=초기화 블록
 * 				class A
 * 				{
 * 					선언
 * 					{
 * 						구현 => 인스턴스 블럭 ... 인스턴스 변수 초기화 여기서 가능
 * 					}
 * 					static
 * 					{
 * 						정적블럭 ... static 변수 초기화 여기서 가능
 * 					}
 * 				}
 * 		===============================================================
 * 	
 * 
 * ***
 * 		함수 vs 메소드 
 * 		함수 : 독립적으로 수행 
 * 		메소드 : 클래스 안에서 작업
 * 		
 * 		객체지향 프로그램 => 모아서 처리(관련된 기능만 처리 )=> 재사용
 * 		메소드 => *한 가지* 기능만 수행이 가능하게 만든다.
 * 
 * 		모든 클래스의 메소드 제작
 * 		==================
 * 		1. 입력 
 * 		2. 처리 => 세부화 (여러개)
 * 		3. 출력
 * 		4. 조립
 * 
 * 		======= 달력 ==> 공통적으로 사용하는 데이터 (멤버변수)
 * 							==> 힙
 * 						메소드 안에서만 사용하는 변수 (지역변수)
 * 						지역변수 : 블록변수(블록이 종료되면 사라지는 변수 ) 
 * 							==> 스택
 * 
 * 
 * 					JVM (자바 가상머신)
 * 				===============================
 * 					메소드 (static)
 * 				===============================
 * 					지역변수 (매갭ㄴ수, 메소드안의 변수 )	=>  스택 
 * 												.. 메모리에 의해서 자동으로 관리(블록 사라지만 자동으로 사라짐)				
 * 				===============================
 * 					멤버변수 => 힙 (가비지 컬렉션 )
 * 							... 사용자에 의해서 처리( 멤버변수 선언되면 사용자가 지우지 않는 한 사라지지 않음 ... 프로그램 종료시까지 사용 가능)
 * 				===============================
 * 		1. 입력 ==> year , month
 * 			년도/월
 * 		2. 1일자의 요일을 구한다 ==> year , month , lastday 
 * 		3. 화면에 출력  year, month, lastday, week
 * 		4. 조립
 * 		---------------------------------------------------메소드 여러군데에서 사용되면 전역변수(멤버변수)로 사용 ..
 * 			.... 어디에서 변수가 사용되는지 확인 후 변수 결정하자아아아

 * 
 */

//입력
import java.util.*;//Scanner => 나중엔 IO(BufferedReader) 로 사용 .. 스캐너보다 안정적 ㅎㅎ
// IO => System.in(키보드 입력) , System.out(화면 출력)
class MyDate
{
	//데이터 변질 => 은닉화 (MyDate 에서 사용하는 변수)
	private int year, month , week;
	private int[] lastday= {31,28,31,30,31,30,
							31,31,30,31,30,31};//각 달의 마지막 날짜
	//사용자 입력
	//메소드 => 구조화 (단락), 반복 제거 , 한가지 기능을 수행
	public int input(String msg)//년도 , 월
	{
		Scanner scan=new Scanner(System.in);
		System.out.print(msg+"입력: ");
		return scan.nextInt();
	}
	// 1일자의 요일을 생성 
	public int getWeek()
	{
		int week=0;
		//1. 전년도까지의 총 일수( 1년도 1일 => 월) ==> %7
		int total =(year-1)*365
				+(year-1)/4
				-(year-1)/100
				+(year-1)/400;  //윤년 계산법 ***** 로마시대때부터 내려온 계산식 ㅋㅋ
		//2. 전달까지의 총 일수
		if((year%4==0 && year%100!=0) ||(year%400==0))//윤년이면
			lastday[1]=29;
		else
			lastday[1]=28;
		for(int i=0;i<month-1;i++) 
		{
			total+=lastday[i];
		}
		//3. +1
		total++;
		
		//====================요청한 날짜의 1일자의 요일 확인 가능
		week=total%7;
		return week;
	}
	// 사용자가 요청한 달력을 보여준다
	public void datePrint()
	{
		String[] strWeek= {"일","월","화","수","목","금","토"};
		for(String s: strWeek)
		{
			System.out.print(s+"\t");
		}
		System.out.println("\n");
		for(int i=1;i<=lastday[month-1];i++) {
			if(i==1) // 첫 줄에 공백
			{
				for(int j=0;j<week;j++)
				{
					System.out.print("\t");
				}
			}
			System.out.printf("%2d\t",i); //달력 출력
			week++;
			if(week>6)//토요일이면
			{
				week=0;//일요일로 변경
				System.out.println();//다음 줄에 출력
			}
		}
	}
	// 조립 => 기능 없이 합쳐주기만
	public void process() //조립 후 출력만 .. 결과값 없음 => 이럴때 void
	{
		//사용자 요청값 받기
		year=input("년도");
//		int month=input("월");///lastday[month-1]=> lastday[-1]
		month=input("월");
		
		System.out.println(year+"년도"+month+"월");
		week=getWeek();
		datePrint();
		
	}
	
}
public class MainClass {

	public static void main(String[] args) {
		//1. 메몸리 할당
		MyDate md=new MyDate();
		md.process();
	}
}
